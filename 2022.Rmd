---
title: "Fire_NOBO_Manuscript"
output: html_document
date: "2025-08-28"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading libraries
```{r}
library(janitor)
library(tidyverse)
library(ggthemes)
library(lubridate)
library(lme4)
library(readxl)
library(writexl)
library(sf)
library(MuMIn)
library(scales)
library(sjPlot)
library(rsq)
library(betareg)
library(broom)
library(caret)
library(performance)
library(gam)
library(mgcv)
theme_set(theme_minimal())
```

Loading datasets
```{r}
#Importing summer locations, already joined with veg data and birds online.
summer2022_locs_veg_data <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/SummerLocations/Summer2022/summer_2022_points_veg_CorrectBirdsOnline.xlsx") %>%
  mutate(date = ymd(date)) %>%
  dplyr::filter(status != "D") 

#Importing veg data
veg_data_2022 <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/VegSurveys/VegSurveys2022.xlsx") %>%
  clean_names()

```


#### Determining proportion of birds located in burned areas daily ####
```{r}
# Counting unique birds signaled within a burned area each day
birds_in_burned_areas <- summer2022_locs_veg_data %>%
  dplyr::filter(burned == 1) %>%
  group_by(date) %>%
  summarize(birds_in_burned_areas = n_distinct(band_numb))


# Joining into summer locs data
summer2022_locs_veg_data <- summer2022_locs_veg_data %>%
  left_join(birds_in_burned_areas, by = "date")

# Handling NA values for birds_in_burned_areas
summer2022_locs_veg_data$birds_in_burned_areas[is.na(summer2022_locs_veg_data$birds_in_burned_areas)] <- 0

# Calculate percentage of birds in burned areas
s22rx <- summer2022_locs_veg_data %>%
  mutate(pib = (birds_in_burned_areas / birds_online))

# Handling NA values for pib
s22rx$pib[is.na(s22rx$pib)] <- 0
```


Lets add a distance to edge column for our points 
```{r}
#### Importing map of burned areas, calculating distance ####

#Importing map of burned areas, summer 2022.
#Reading burn compartments in again, but as an sf object
burn_compartments_2022 <- st_read("/Volumes/Samsung_T5/BOBWHITE_DATA/Maps/2022_burn_compartments/Polygons/NoAG_NoHW/2022_burn_units_NoAG_NoHW.shp")

# Converting burn_compartments_2022 polygons to line geometries that represent their boundaries. This is necessary to calc min distances later.
burn_compartment_boundaries <- st_boundary(burn_compartments_2022)

# Converting tibble of points to an sf object
summer2022_locs_sf <- st_as_sf(s22rx, coords = c("easting", "northing"), crs = st_crs(burn_compartments_2022))

# Calculating the distance from each point to the nearest line boundary of the burn compartments, storing it in matrix
distance_matrix <- st_distance(summer2022_locs_sf, burn_compartment_boundaries)

# Applying the function min() to each row (1 does this -- we'd use 2 for columns) in the distance matrix
min_distances <- apply(distance_matrix, 1, min)

# Add the minimum distance to the original tibble as a new column
s22rx$distance_to_edge <- min_distances


#This looks right, and similar to what we got in other analysis. Adding a vline to DSF = 56 (Date of supplemental feeding)
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(DSF, distance_to_edge)) +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  geom_point() +
  labs(x = "Days since fire",
       y = "Distance to perimeter of burn unit (m)") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


#Distance model. Can we predict dist to edge with DSF
dist_model <- lmer(distance_to_edge ~ DSF + (1 | band_numb), 
                    data = s22rx %>% dplyr::filter(burned == 1))
#Summarizing distance model
summary(dist_model)

#Mean distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Histogram of distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 10, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 28, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds within burn compartments")

  
#Mean distance to edge of burned units for quail NOT in burned areas.
s22rx %>%
  dplyr::filter(burned == 0) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Distance to edge histogram for birds NOT in burned units
s22rx %>%
  dplyr::filter(burned == 0) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 20, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 95.8, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds in unburned compartments")

#Boxplot comparing distance to edge of burned units (Birds in unburned areas vs birds in burned areas)
s22rx %>%
  mutate(burned = factor(burned, labels = c("Unburned", "Burned"))) %>%
  ggplot(aes(x = burned, y = distance_to_edge)) +
  geom_boxplot(fill = "midnight blue", alpha = 0.5) +
  labs(x = "Burn Status",
       y = "Distance to Edge",
       title = "Distance to edge of burn compartments following prescribed fire")

#Making a separate dataframe for birds in burned units and distance to edge.
s22dist <- s22rx %>%
  dplyr::select(burned, distance_to_edge)
```

Plot of DSV and PIB, with vertical line at sup feed date.
```{r}
#Create one row for each day. May need this later.
s22rx_uniq <- s22rx %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

s22rx_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  labs(x = "Days since fire", y = "PIB") +
   theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))
```


Now lets separate s22rx into "before supplemental feed" and "after supplemental feed". 
Supplemental feed began on June 6th (DSF = 56)
```{r}
#Creating dataframe for "before supplemental feed"
s22rx_pre <- s22rx %>%
  filter(DSF < 56)

s22rx_post <- s22rx %>%
  filter(DSF >= 56)
```


Centering and scaling our vegetation covariates. Selecting relevant columns.
Removing Duplicate Rows, so we only have 1 row per day.
```{r}
#Centering and scaling pre-sup feed. Adding small value to pib so it never = 0. 
s22rx_pre_sc <- s22rx_pre %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Centering and scaling post-sup feed. Adding small value to pib so it never = 0. 
s22rx_post_sc <- s22rx_post %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Selecting relevant columns, pre-sup feed.
s22rx_pre <- s22rx_pre %>%
  dplyr::select(pib, DSF, pg:hs)

#Selecting relevant columns, post-sup feed.
s22rx_post <- s22rx_post %>%
  dplyr::select(pib, DSF, pg:hs)


#Creating only one row per day, pre-sup.
s22rx_pre_uniq <- s22rx_pre %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

#Creating only one row per day, post-sup.
s22rx_post_uniq <- s22rx_post %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()
```

Checking for correlations in veg data.
```{r}
#Selecting veg, pre-sup feed
pre_veg <- s22rx_pre_sc %>%
  dplyr::select(pg:hs)

#Pre-sup, veg cor
round(cor(pre_veg), 2)

#Selecting veg, pre-sup feed
post_veg <- s22rx_post_sc %>%
  dplyr::select(pg:hs)

#Pre-sup, veg cor
round(cor(post_veg), 2)
```

Plot of use of burned areas in time.
```{r}
#Pre-sup feed
s22rx_pre_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
        labs(x = "DSF", y = "PIB")

#Post-sup feed
s22rx_post_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
        labs(x = "DSF", y = "PIB")
```

#Pre-sup: Predicting PIB using PF.
```{r}    
library(betareg)
library(dplyr)
library(ggplot2)

# Base model (center line)
pf_model <- betareg(pib ~ pf,
                    data = s22rx_pre_uniq,
                    link = "logit",
                    na.action = na.pass)

# Prediction grid over pf
pf_values <- seq(min(s22rx_pre_uniq$pf, na.rm = TRUE),
                 max(s22rx_pre_uniq$pf, na.rm = TRUE),
                 length.out = 1000)
newdata <- data.frame(pf = pf_values)

# Parametric predictions from the fitted model (for the black line)
predicted_pib <- predict(pf_model, newdata = newdata, type = "response")

# Bootstrap CIs via case-resampling
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = length(pf_values))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(s22rx_pre_uniq), replace = TRUE)
  resample_data <- s22rx_pre_uniq[resample_idx, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit <- tryCatch(
    betareg(pib ~ pf, data = resample_data, link = "logit", na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 95% percentile CIs
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata
newdata$predicted_pib <- predicted_pib
newdata$ci_lower <- ci_lower
newdata$ci_upper <- ci_upper

# Plot: raw data, prediction line, CI ribbon
ggplot(newdata, aes(x = pf)) +
  geom_point(data = s22rx_pre_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent Forbs",  
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

newdata$DSF <- seq(min(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   max(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   length.out = nrow(newdata))

ggplot(newdata, aes(x = DSF)) +
  geom_point(data = s22rx_pre_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Pre-supplemental period") +
   theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

```

#Post-sup: Predicting PIB using PF
```{r}
library(betareg)
library(dplyr)
library(ggplot2)

# Base model (center line) — POST period
pf_model <- betareg(pib ~ pf,
                    data = s22rx_post_uniq,
                    link = "logit",
                    na.action = na.pass)

# Prediction grid over pf (POST)
pf_values <- seq(min(s22rx_post_uniq$pf, na.rm = TRUE),
                 max(s22rx_post_uniq$pf, na.rm = TRUE),
                 length.out = 1000)
newdata <- data.frame(pf = pf_values)

# Parametric predictions from the fitted model (for the black line)
predicted_pib <- predict(pf_model, newdata = newdata, type = "response")

# Bootstrap CIs via case-resampling (POST)
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = length(pf_values))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(s22rx_post_uniq), replace = TRUE)
  resample_data <- s22rx_post_uniq[resample_idx, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit <- tryCatch(
    betareg(pib ~ pf, data = resample_data, link = "logit", na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 95% percentile CIs
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata
newdata$predicted_pib <- predicted_pib
newdata$ci_lower <- ci_lower
newdata$ci_upper <- ci_upper

# Plot: raw data (POST), prediction line, CI ribbon — x = pf
ggplot(newdata, aes(x = pf)) +
  geom_point(data = s22rx_post_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent Forbs",
       y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

# (Optional) Show DSF on the x-axis (POST) — adds a DSF sequence just for plotting
newdata$DSF <- seq(min(s22rx_post_uniq$DSF, na.rm = TRUE),
                   max(s22rx_post_uniq$DSF, na.rm = TRUE),
                   length.out = nrow(newdata))

ggplot(newdata, aes(x = DSF)) +
  geom_point(data = s22rx_post_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))
```

