---
title: "Fire_NOBO_Manuscript"
output: html_document
date: "2025-08-28"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading libraries
```{r}
library(janitor)
library(tidyverse)
library(ggthemes)
library(lubridate)
library(lme4)
library(readxl)
library(writexl)
library(sf)
library(MuMIn)
library(scales)
library(sjPlot)
library(rsq)
library(betareg)
library(broom)
library(caret)
library(performance)
library(gam)
library(mgcv)
theme_set(theme_minimal())
```

Loading datasets
```{r}
#Importing summer locations, already joined with veg data and birds online.
summer2022_locs_veg_data <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/SummerLocations/Summer2022/summer_2022_points_veg_CorrectBirdsOnline.xlsx") %>%
  mutate(date = ymd(date)) %>%
  dplyr::filter(status == "A") 

#Importing veg data
veg_data_2022 <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/VegSurveys/VegSurveys2022.xlsx") %>%
  clean_names()

```


#### Determining proportion of birds located in burned areas daily ####
```{r}
# Counting unique birds signaled within a burned area each day
birds_in_burned_areas <- summer2022_locs_veg_data %>%
  dplyr::filter(burned == 1) %>%
  group_by(date) %>%
  summarize(birds_in_burned_areas = n_distinct(band_numb))


# Joining into summer locs data
summer2022_locs_veg_data <- summer2022_locs_veg_data %>%
  left_join(birds_in_burned_areas, by = "date")

# Handling NA values for birds_in_burned_areas
summer2022_locs_veg_data$birds_in_burned_areas[is.na(summer2022_locs_veg_data$birds_in_burned_areas)] <- 0

# Calculate percentage of birds in burned areas
s22rx <- summer2022_locs_veg_data %>%
  mutate(pib = (birds_in_burned_areas / birds_online))

# Handling NA values for pib
s22rx$pib[is.na(s22rx$pib)] <- 0
```


Lets add a distance to edge column for our points 
```{r}
#### Importing map of burned areas, calculating distance ####

#Importing map of burned areas, summer 2022.
#Reading burn compartments in again, but as an sf object
burn_compartments_2022 <- st_read("/Volumes/Samsung_T5/BOBWHITE_DATA/Maps/2022_burn_compartments/Polygons/NoAG_NoHW/2022_burn_units_NoAG_NoHW.shp")

# Converting burn_compartments_2022 polygons to line geometries that represent their boundaries. This is necessary to calc min distances later.
burn_compartment_boundaries <- st_boundary(burn_compartments_2022)

# Converting tibble of points to an sf object
summer2022_locs_sf <- st_as_sf(s22rx, coords = c("easting", "northing"), crs = st_crs(burn_compartments_2022))

# Calculating the distance from each point to the nearest line boundary of the burn compartments, storing it in matrix
distance_matrix <- st_distance(summer2022_locs_sf, burn_compartment_boundaries)

# Applying the function min() to each row (1 does this -- we'd use 2 for columns) in the distance matrix
min_distances <- apply(distance_matrix, 1, min)

# Add the minimum distance to the original tibble as a new column
s22rx$distance_to_edge <- min_distances


#This looks right, and similar to what we got in other analysis. Adding a vline to DSF = 56 (Date of supplemental feeding)
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(DSF, distance_to_edge)) +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  geom_point() +
  labs(x = "Days since fire",
       y = "Distance to perimeter of burn unit (m)") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


#Distance model. Can we predict dist to edge with DSF
dist_model <- lmer(distance_to_edge ~ DSF + (1 | band_numb), 
                    data = s22rx %>% dplyr::filter(burned == 1))
#Summarizing distance model
summary(dist_model)

#Mean distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Histogram of distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 10, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 28, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds within burn compartments")

  
#Mean distance to edge of burned units for quail NOT in burned areas.
s22rx %>%
  dplyr::filter(burned == 0) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Distance to edge histogram for birds NOT in burned units
s22rx %>%
  dplyr::filter(burned == 0) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 20, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 95.8, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds in unburned compartments")

#Boxplot comparing distance to edge of burned units (Birds in unburned areas vs birds in burned areas)
s22rx %>%
  mutate(burned = factor(burned, labels = c("Unburned", "Burned"))) %>%
  ggplot(aes(x = burned, y = distance_to_edge)) +
  geom_boxplot(fill = "midnight blue", alpha = 0.5) +
  labs(x = "Burn Status",
       y = "Distance to Edge",
       title = "Distance to edge of burn compartments following prescribed fire")

#Making a separate dataframe for birds in burned units and distance to edge.
s22dist <- s22rx %>%
  dplyr::select(burned, distance_to_edge)
```

Plot of DSF and PIB, with vertical line at sup feed date.
```{r}
#Create one row for each day. May need this later.
s22rx_uniq <- s22rx %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

s22rx_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  labs(x = "Days since fire", y = "PIB", title = "2022") +
   theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))
```


Now lets separate s22rx into "before supplemental feed" and "after supplemental feed". 
Supplemental feed began on June 6th (DSF = 56)
```{r}
#Creating dataframe for "before supplemental feed"
s22rx_pre <- s22rx %>%
  filter(DSF < 56)

s22rx_post <- s22rx %>%
  filter(DSF >= 56)
```


Centering and scaling our vegetation covariates. Selecting relevant columns.
Removing Duplicate Rows, so we only have 1 row per day.
```{r}
#Centering and scaling pre-sup feed. Adding small value to pib so it never = 0. 
s22rx_pre_sc <- s22rx_pre %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Centering and scaling post-sup feed. Adding small value to pib so it never = 0. 
s22rx_post_sc <- s22rx_post %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Selecting relevant columns, pre-sup feed.
s22rx_pre <- s22rx_pre %>%
  dplyr::select(pib, DSF, week, pg:hs)

#Selecting relevant columns, post-sup feed.
s22rx_post <- s22rx_post %>%
  dplyr::select(pib, DSF,week, pg:hs)


#Creating only one row per day, pre-sup.
s22rx_pre_uniq <- s22rx_pre %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

#Creating only one row per day, post-sup.
s22rx_post_uniq <- s22rx_post %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()
```

#### Checking for correlations in veg data.####
```{r}
#Selecting veg, pre-sup feed
pre_veg <- s22rx_pre_sc %>%
  dplyr::select(pg:hs)

#Pre-sup, veg cor
round(cor(pre_veg), 2)

#Selecting veg, pre-sup feed
post_veg <- s22rx_post_sc %>%
  dplyr::select(pg:hs)

#Pre-sup, veg cor
round(cor(post_veg), 2)
```

Plot of use of burned areas in time.
```{r}
#Pre-sup feed
s22rx_pre_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
        labs(x = "DSF", y = "PIB")

#Post-sup feed
s22rx_post_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
        labs(x = "DSF", y = "PIB")
```

#Pre-sup: Predicting PIB using PS.
```{r}    
library(betareg)
library(dplyr)
library(ggplot2)

# Base model (center line)
ps_model <- betareg(pib ~ ps,
                    data = s22rx_pre_uniq,
                    link = "logit",
                    na.action = na.pass)

# Prediction grid over pf
ps_values <- seq(min(s22rx_pre_uniq$ps, na.rm = TRUE),
                 max(s22rx_pre_uniq$ps, na.rm = TRUE),
                 length.out = 1000)
newdata <- data.frame(ps = ps_values)

# Parametric predictions from the fitted model (for the black line)
predicted_pib <- predict(ps_model, newdata = newdata, type = "response")

# Bootstrap CIs via case-resampling
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = length(ps_values))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(s22rx_pre_uniq), replace = TRUE)
  resample_data <- s22rx_pre_uniq[resample_idx, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit <- tryCatch(
    betareg(pib ~ ps, data = resample_data, link = "logit", na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 95% percentile CIs
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata
newdata$predicted_pib <- predicted_pib
newdata$ci_lower <- ci_lower
newdata$ci_upper <- ci_upper

# Plot: raw data, prediction line, CI ribbon
ggplot(newdata, aes(x = ps)) +
  geom_point(data = s22rx_pre_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrubs",  
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

newdata$DSF <- seq(min(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   max(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   length.out = nrow(newdata))

ggplot(newdata, aes(x = DSF)) +
  geom_point(data = s22rx_pre_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Pre-supplemental period") +
   theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

ggplot(newdata, aes(x = ps)) +
  geom_point(data = s22rx_pre_uniq,
             aes(x = ps, y = pib),
             size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

ggplot(newdata, aes(x = ps)) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


```

#Post-sup: Predicting PIB using PS
```{r}
library(betareg)
library(dplyr)
library(ggplot2)

# Base model (center line) — POST period
ps_model <- betareg(pib ~ ps,
                    data = s22rx_post_uniq,
                    link = "logit",
                    na.action = na.pass)

# Prediction grid over pf (POST)
ps_values <- seq(min(s22rx_post_uniq$ps, na.rm = TRUE),
                 max(s22rx_post_uniq$ps, na.rm = TRUE),
                 length.out = 1000)
newdata <- data.frame(ps = ps_values)

# Parametric predictions from the fitted model (for the black line)
predicted_pib <- predict(ps_model, newdata = newdata, type = "response")

# Bootstrap CIs via case-resampling (POST)
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = length(ps_values))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(s22rx_post_uniq), replace = TRUE)
  resample_data <- s22rx_post_uniq[resample_idx, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit <- tryCatch(
    betareg(pib ~ ps, data = resample_data, link = "logit", na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 95% percentile CIs
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata
newdata$predicted_pib <- predicted_pib
newdata$ci_lower <- ci_lower
newdata$ci_upper <- ci_upper

# Plot: raw data (POST), prediction line, CI ribbon — x = pf
ggplot(newdata, aes(x = ps)) +
  geom_point(data = s22rx_post_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover",
       y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

#Making data frame to plot DSF on the X axis
newdata$DSF <- seq(min(s22rx_post_uniq$DSF, na.rm = TRUE),
                   max(s22rx_post_uniq$DSF, na.rm = TRUE),
                   length.out = nrow(newdata))

ggplot(newdata, aes(x = DSF)) +
  geom_point(data = s22rx_post_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))
```

Now lets look at rainfall 2022
```{r}
#Importing weather data
weather <- read_xlsx("/Users/grayum.jeffrey/Downloads/Crafton_rainfall_2022 .xlsx") %>%
  clean_names()

#Selecting relevant columns
rain <- weather %>%
  select(date, rain_total_mm)

#Fixing date column
rain <- rain %>%
  mutate(date = ymd(date))

#Setting brun date
burn_date <- ymd("2022-04-11")

#Creating dsf
rain <- weather %>%
  select(date, rain_total_mm) %>%
  mutate(date = ymd(date),
         dsf = as.integer(date - burn_date))

rain %>%
  ggplot(aes(dsf, rain_total_mm)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  labs(x = "DSF", y = "Rain total (mm)", title = "2022")

#Plot of 
rain %>%
  arrange(date) %>%
  mutate(cum_rain = cumsum(rain_total_mm)) %>%
  ggplot(aes(x = date, y = cum_rain)) +
  geom_line(color = "darkblue", linewidth = 1.2) +
  labs(x = "Date", y = "Cumulative rainfall (mm)", 
       title = "2022") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

rain %>%
  arrange(dsf) %>%
  mutate(cum_rain = cumsum(rain_total_mm)) %>%
  ggplot(aes(x = dsf, y = cum_rain)) +
  geom_line(color = "darkblue", linewidth = 1.2) +
  labs(x = "Days since fire", 
       y = "Cumulative rainfall (mm)", 
       title = "2022") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))
```


#### CHATGPT VERSION ####
```{r}
#### Loading datasets ####
#Importing summer locations, already joined with veg data and birds online.
summer2022_locs_veg_data <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/SummerLocations/Summer2022/summer_2022_points_veg_CorrectBirdsOnline.xlsx") %>%
  mutate(date = ymd(date)) %>%
  dplyr::filter(status == "A") 

#Importing veg data
veg_data_2022 <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/VegSurveys/VegSurveys2022.xlsx") %>%
  clean_names()


#### Determining proportion of birds located in burned areas daily ####
# Counting unique birds signaled within a burned area each day
birds_in_burned_areas <- summer2022_locs_veg_data %>%
  dplyr::filter(burned == 1) %>%
  group_by(date) %>%
  summarize(birds_in_burned_areas = n_distinct(band_numb))

# Joining into summer locs data
summer2022_locs_veg_data <- summer2022_locs_veg_data %>%
  left_join(birds_in_burned_areas, by = "date")

# Handling NA values for birds_in_burned_areas
summer2022_locs_veg_data$birds_in_burned_areas[is.na(summer2022_locs_veg_data$birds_in_burned_areas)] <- 0

# Calculate percentage of birds in burned areas
s22rx <- summer2022_locs_veg_data %>%
  mutate(pib = (birds_in_burned_areas / birds_online))

# Handling NA values for pib
s22rx$pib[is.na(s22rx$pib)] <- 0


#### Lets add a distance to edge column for our points ####
#### Importing map of burned areas, calculating distance ####

#Importing map of burned areas, summer 2022.
#Reading burn compartments in again, but as an sf object
burn_compartments_2022 <- st_read("/Volumes/Samsung_T5/BOBWHITE_DATA/Maps/2022_burn_compartments/Polygons/NoAG_NoHW/2022_burn_units_NoAG_NoHW.shp")

# Converting burn_compartments_2022 polygons to line geometries that represent their boundaries. This is necessary to calc min distances later.
burn_compartment_boundaries <- st_boundary(burn_compartments_2022)

# Converting tibble of points to an sf object
summer2022_locs_sf <- st_as_sf(s22rx, coords = c("easting", "northing"), crs = st_crs(burn_compartments_2022))

# Calculating the distance from each point to the nearest line boundary of the burn compartments, storing it in matrix
distance_matrix <- st_distance(summer2022_locs_sf, burn_compartment_boundaries)

# Applying the function min() to each row (1 does this -- we'd use 2 for columns) in the distance matrix
min_distances <- apply(distance_matrix, 1, min)

# Add the minimum distance to the original tibble as a new column
s22rx$distance_to_edge <- min_distances


#This looks right, and similar to what we got in other analysis. Adding a vline to DSF = 56 (Date of supplemental feeding)
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(DSF, distance_to_edge)) +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  geom_point() +
  labs(x = "Days since fire",
       y = "Distance to perimeter of burn unit (m)") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


#Distance model. Can we predict dist to edge with DSF
dist_model <- lmer(distance_to_edge ~ DSF + (1 | band_numb), 
                   data = s22rx %>% dplyr::filter(burned == 1))
#Summarizing distance model
summary(dist_model)

#Mean distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Histogram of distance to edge
s22rx %>%
  dplyr::filter(burned == 1) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 10, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 28, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds within burn compartments")


#Mean distance to edge of burned units for quail NOT in burned areas.
s22rx %>%
  dplyr::filter(burned == 0) %>%
  summarize(mean_distance = mean(distance_to_edge))


#Distance to edge histogram for birds NOT in burned units
s22rx %>%
  dplyr::filter(burned == 0) %>%
  ggplot(aes(distance_to_edge)) +
  geom_histogram(binwidth = 20, fill = "midnight blue", alpha = 0.8) + 
  geom_vline(xintercept = 95.8, linetype = "dashed", color = "gray") +
  labs(x = "Distance to edge",
       y = "",
       title = "Distances to edge following prescribed fire",
       subtitle = "Only looking at birds in unburned compartments")

#Boxplot comparing distance to edge of burned units (Birds in unburned areas vs birds in burned areas)
s22rx %>%
  mutate(burned = factor(burned, labels = c("Unburned", "Burned"))) %>%
  ggplot(aes(x = burned, y = distance_to_edge)) +
  geom_boxplot(fill = "midnight blue", alpha = 0.5) +
  labs(x = "Burn Status",
       y = "Distance to Edge",
       title = "Distance to edge of burn compartments following prescribed fire")

#Making a separate dataframe for birds in burned units and distance to edge.
s22dist <- s22rx %>%
  dplyr::select(burned, distance_to_edge)


#### Plot of DSV and PIB, with vertical line at sup feed date. ####
#Create one row for each day. May need this later.
s22rx_uniq <- s22rx %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

s22rx_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  geom_vline(xintercept = 56, linetype = "dashed", color = "midnight blue") +
  labs(x = "Days since fire", y = "PIB", title = "2022") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


#### Now lets separate s22rx into "before supplemental feed" and "after supplemental feed". ####
#### Supplemental feed began on June 6th (DSF = 56) ####
#Creating dataframe for "before supplemental feed"
s22rx_pre <- s22rx %>%
  filter(DSF < 56)

s22rx_post <- s22rx %>%
  filter(DSF >= 56)


#### Centering and scaling our vegetation covariates. Selecting relevant columns. ####
#### Removing Duplicate Rows, so we only have 1 row per day. ####
#Centering and scaling pre-sup feed. Adding small value to pib so it never = 0. 
s22rx_pre_sc <- s22rx_pre %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Centering and scaling post-sup feed. Adding small value to pib so it never = 0. 
s22rx_post_sc <- s22rx_post %>% 
  mutate_at(vars(pg:hs), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

#Selecting relevant columns, pre-sup feed.
s22rx_pre <- s22rx_pre %>%
  dplyr::select(pib, DSF, week, start_date_of_week, pg:hs)

#Selecting relevant columns, post-sup feed.
s22rx_post <- s22rx_post %>%
  dplyr::select(pib, DSF,week, start_date_of_week, pg:hs)


#Creating only one row per day, pre-sup.
s22rx_pre_uniq <- s22rx_pre %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()

#Creating only one row per day, post-sup.
s22rx_post_uniq <- s22rx_post %>% 
  group_by(DSF) %>%
  slice_head(n = 1) %>%
  ungroup()


#### Checking for correlations in veg data. ####
#Selecting veg, pre-sup feed
veg22 <- s22rx_uniq %>%
  dplyr::select(pg:hs)

veg_cor22 <- round(cor(veg22), 2)

veg_cor22_df <- veg_cor22 %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "variable")

# Write to Excel
write_xlsx(
  veg_cor22_df,
  "/Volumes/Samsung_T5/FIRE_NOBO_MANUSCRIPT/veg_cor22.xlsx"
)

#Selecting veg, pre-sup feed
post_veg <- s22rx_post_sc %>%
  dplyr::select(pg:hs)

#Pre-sup, veg cor
round(cor(post_veg), 2)


#### Plot of use of burned areas in time. ####
#Pre-sup feed
s22rx_pre_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  labs(x = "DSF", y = "PIB")

#Post-sup feed
s22rx_post_uniq %>%
  ggplot(aes(DSF, pib)) +
  geom_point() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  labs(x = "DSF", y = "PIB")


#### Pre-sup: Predicting PIB using PS. ####
library(betareg)
library(dplyr)
library(ggplot2)

# *** IMPORTANT CHANGE FOR BETAREG ***
# Ensure PIB is strictly within (0, 1) for beta regression
s22rx_pre_uniq <- s22rx_pre_uniq %>%
  mutate(pib = pmin(pmax(pib, 1e-5), 1 - 1e-5))

# Base model (center line)
ps_model <- betareg(pib ~ ps,
                    data = s22rx_pre_uniq,
                    link = "logit",
                    na.action = na.pass)

summary(ps_model)

# Prediction grid over ps
ps_values <- seq(min(s22rx_pre_uniq$ps, na.rm = TRUE),
                 max(s22rx_pre_uniq$ps, na.rm = TRUE),
                 length.out = 1000)
newdata <- data.frame(ps = ps_values)

# Parametric predictions from the fitted model (for the black line)
predicted_pib <- predict(ps_model, newdata = newdata, type = "response")

# Bootstrap CIs via case-resampling
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = length(ps_values))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(s22rx_pre_uniq), replace = TRUE)
  resample_data <- s22rx_pre_uniq[resample_idx, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit <- tryCatch(
    betareg(pib ~ ps, data = resample_data, link = "logit", na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 95% percentile CIs
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata
newdata$predicted_pib <- predicted_pib
newdata$ci_lower <- ci_lower
newdata$ci_upper <- ci_upper

# Plot: raw data, prediction line, CI ribbon (ps on x-axis)
ggplot(newdata, aes(x = ps)) +
  geom_point(data = s22rx_pre_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrubs",  
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

# Add a DSF sequence (cosmetic x-axis relabel using same predicted_pib)
newdata$DSF <- seq(min(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   max(s22rx_pre_uniq$DSF, na.rm = TRUE),
                   length.out = nrow(newdata))

ggplot(newdata, aes(x = DSF)) +
  geom_point(data = s22rx_pre_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

ggplot(newdata, aes(x = ps)) +
  geom_point(data = s22rx_pre_uniq,
             aes(x = ps, y = pib),
             size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

ggplot(newdata, aes(x = ps)) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Pre-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


#### Post-sup: Predicting PIB using PS. ####

# Ensure PIB is strictly within (0, 1) for beta regression
s22rx_post_uniq <- s22rx_post_uniq %>%
  mutate(pib = pmin(pmax(pib, 1e-5), 1 - 1e-5))

# Base model (center line) for post-supplemental period
ps_model_post <- betareg(pib ~ ps,
                         data = s22rx_post_uniq,
                         link = "logit",
                         na.action = na.pass)

summary(ps_model_post)

# Prediction grid over ps for post-supplemental period
ps_values_post <- seq(min(s22rx_post_uniq$ps, na.rm = TRUE),
                      max(s22rx_post_uniq$ps, na.rm = TRUE),
                      length.out = 1000)

newdata_post <- data.frame(ps = ps_values_post)

# Parametric predictions from the fitted model (for the black line)
predicted_pib_post <- predict(ps_model_post,
                              newdata = newdata_post,
                              type = "response")

# Bootstrap CIs via case-resampling (post-supplemental)
set.seed(456)
n_boot_post <- 1000
boot_preds_post <- matrix(NA_real_, nrow = n_boot_post, ncol = length(ps_values_post))

for (i in seq_len(n_boot_post)) {
  resample_idx_post  <- sample(nrow(s22rx_post_uniq), replace = TRUE)
  resample_data_post <- s22rx_post_uniq[resample_idx_post, ]

  # Refit and predict; skip failed fits gracefully
  boot_fit_post <- tryCatch(
    betareg(pib ~ ps,
            data = resample_data_post,
            link = "logit",
            na.action = na.pass),
    error = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit_post)) {
    boot_preds_post[i, ] <- tryCatch(
      predict(boot_fit_post, newdata = newdata_post, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata_post))
    )
  }
}

# 95% percentile CIs for post-supplemental period
ci_lower_post <- apply(boot_preds_post, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper_post <- apply(boot_preds_post, 2, quantile, probs = 0.975, na.rm = TRUE)

# Attach to newdata_post
newdata_post$predicted_pib <- predicted_pib_post
newdata_post$ci_lower      <- ci_lower_post
newdata_post$ci_upper      <- ci_upper_post

# Plot 1: raw data, prediction line, CI ribbon (ps on x-axis) – post-supplemental
ggplot(newdata_post, aes(x = ps)) +
  geom_point(data = s22rx_post_uniq, aes(y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrubs",  
       y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

# Optional: Add a DSF sequence (cosmetic x-axis relabel using same predicted_pib)
newdata_post$DSF <- seq(min(s22rx_post_uniq$DSF, na.rm = TRUE),
                        max(s22rx_post_uniq$DSF, na.rm = TRUE),
                        length.out = nrow(newdata_post))

ggplot(newdata_post, aes(x = DSF)) +
  geom_point(data = s22rx_post_uniq, aes(x = DSF, y = pib), size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Days since fire", y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

# Plot 3: ps vs PIB with line + ribbon only (no points), post-supplemental
ggplot(newdata_post, aes(x = ps)) +
  geom_point(data = s22rx_post_uniq,
             aes(x = ps, y = pib),
             size = 2, alpha = 0.7) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

ggplot(newdata_post, aes(x = ps)) +
  geom_line(aes(y = predicted_pib), linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2) +
  labs(x = "Percent shrub cover", 
       y = "PIB",
       title = "2022: Post-supplemental period") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

#LOOCV

beta_loocv <- function(data) {
  
  n <- nrow(data)
  preds <- numeric(n)
  
  for (i in 1:n) {
    train <- data[-i, ]
    test  <- data[i, , drop = FALSE]
    
    fit <- betareg(pib ~ ps, data = train, link = "logit")
    preds[i] <- predict(fit, newdata = test, type = "response")
  }
  
  # Combine predictions + observed
  data$pred <- preds
  
  # Calculate performance metrics
  rmse <- sqrt(mean((data$pib - data$pred)^2))
  cor_obs_pred <- cor(data$pib, data$pred)
  
  list(
    rmse = rmse,
    cor_obs_pred = cor_obs_pred,
    results = data
  )
}

loocv_22_pre  <- beta_loocv(s22rx_pre_uniq)
loocv_22_pre$rmse
loocv_22_pre$cor_obs_pred


loocv_22_post <- beta_loocv(s22rx_post_uniq)
loocv_22_post$rmse
loocv_22_post$cor_obs_pred


#### WAS SUP FEED SIG ####
combined <- bind_rows(
  s22rx_pre_uniq  %>% mutate(feed = 0),
  s22rx_post_uniq %>% mutate(feed = 1)
)

# Beta regression including interaction
m <- betareg(pib ~ ps * feed, data = combined, link = "logit")
summary(m)

loocv_22_pre  <- beta_loocv(s22rx_pre_uniq)
loocv_22_pre$rmse
loocv_22_pre$cor_obs_pred


#### 2022: ps * feed interaction – predictions with period-specific ps ranges ####

# 1. Combine 2022 pre- and post-supp data
combined22 <- bind_rows(
  s22rx_pre_uniq  %>% mutate(feed = 0),
  s22rx_post_uniq %>% mutate(feed = 1)
)

# 2. Fit interaction model
m <- betareg(
  pib ~ ps * feed,
  data      = combined22,
  link      = "logit",
  na.action = na.pass
)
summary(m)

# 3. Build prediction grids with period-specific ps ranges

# Pre-supp (feed = 0)
ps_pre_vals <- seq(
  min(s22rx_pre_uniq$ps, na.rm = TRUE),
  max(s22rx_pre_uniq$ps, na.rm = TRUE),
  length.out = 1000
)
new_pre <- data.frame(
  ps         = ps_pre_vals,
  feed       = 0,
  period_lab = "Pre-supplemental"
)

# Post-supp (feed = 1)
ps_post_vals <- seq(
  min(s22rx_post_uniq$ps, na.rm = TRUE),
  max(s22rx_post_uniq$ps, na.rm = TRUE),
  length.out = 1000
)
new_post <- data.frame(
  ps         = ps_post_vals,
  feed       = 1,
  period_lab = "Post-supplemental"
)

# Combine prediction grid
newdata <- bind_rows(new_pre, new_post)

# 4. Model predictions from fitted interaction model
predicted_pib <- predict(m, newdata = newdata, type = "response")

# 5. Bootstrap CIs for all rows in `newdata` at once
set.seed(123)
n_boot <- 1000
boot_preds <- matrix(NA_real_, nrow = n_boot, ncol = nrow(newdata))

for (i in seq_len(n_boot)) {
  resample_idx  <- sample(nrow(combined), replace = TRUE)
  resample_data <- combined[resample_idx, ]

  boot_fit <- tryCatch(
    betareg(
      pib ~ ps * feed,
      data      = resample_data,
      link      = "logit",
      na.action = na.pass
    ),
    error   = function(e) NULL,
    warning = function(w) invokeRestart("muffleWarning")
  )

  if (!is.null(boot_fit)) {
    boot_preds[i, ] <- tryCatch(
      predict(boot_fit, newdata = newdata, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdata))
    )
  }
}

# 6. 95% CIs for each row of newdata
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025, na.rm = TRUE)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975, na.rm = TRUE)

# 7. Combined prediction table
pred_df <- newdata %>%
  mutate(
    predicted_pib = predicted_pib,
    ci_lower      = ci_lower,
    ci_upper      = ci_upper,
    period_lab    = factor(period_lab,
                           levels = c("Pre-supplemental", "Post-supplemental"))
  )

# 8. Plot: two smooth curves + ribbons, NO points
ggplot(pred_df,
       aes(x = ps, y = predicted_pib,
           color = period_lab, fill = period_lab)) +
  geom_line(linewidth = 1.2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper),
              alpha = 0.2, color = NA) +
  labs(x = "Percent shrub cover",
       y = "PIB",
       color = "Period",
       fill  = "Period",
       title = "2022: Predicted PIB vs shrub cover (pre- and post-supplemental)") +
  theme(legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


## 2022: four candidate models with ps and feed

# 1) Interaction model: pib ~ ps * feed
m22_i <- betareg(
  pib ~ ps * feed,
  data      = combined22,
  link      = "logit",
  na.action = na.pass
)

# 2) Additive model: pib ~ ps + feed
m22_a <- betareg(
  pib ~ ps + feed,
  data      = combined22,
  link      = "logit",
  na.action = na.pass
)

# 3) ps-only model
m22_s <- betareg(
  pib ~ ps,
  data      = combined22,
  link      = "logit",
  na.action = na.pass
)

# 4) feed-only model
m22_f <- betareg(
  pib ~ feed,
  data      = combined22,
  link      = "logit",
  na.action = na.pass
)

# 3. Function to extract summary stats
extract_info <- function(model, name) {
  sm <- summary(model)$coefficients$mean
  
  data.frame(
    Model   = name,
    df      = attr(logLik(model), "df"),
    logLik  = as.numeric(logLik(model)),
    AICc    = MuMIn::AICc(model),
    R2      = unname(performance::r2(model)$R2),   # <- unname to kill "Pseudo R2..." labels
    p_ps    = if ("ps" %in% rownames(sm)) sm["ps", "Pr(>|z|)"] else NA,
    p_feed  = if ("feed" %in% rownames(sm)) sm["feed", "Pr(>|z|)"] else NA,
    p_int   = if ("ps:feed" %in% rownames(sm)) sm["ps:feed", "Pr(>|z|)"] else NA
  )
}

# 4. Build summary table
summary22 <- bind_rows(
  extract_info(m22_i, "ps * feed"),
  extract_info(m22_a, "ps + feed"),
  extract_info(m22_s, "ps only"),
  extract_info(m22_f, "feed only")
) %>%
  arrange(AICc) %>%
  mutate(
    delta  = AICc - min(AICc),
    weight = MuMIn::Weights(AICc)
  )

rownames(summary22) <- NULL  # clean row names

summary22

write_xlsx(summary22, "/Volumes/Samsung_T5/FIRE_NOBO_MANUSCRIPT/model_summary_22.xlsx")

summary(m22_i)


#### Predict plot with two lines (feedn and no feed) ####
# Ensure feed is a factor (for clean plotting)
 combined22 <- combined22 %>%
     mutate(feed_f = factor(feed, levels = c(0,1),
                           labels = c("No supplemental feed", "Supplemental feed")))
 
 m <- betareg(pib ~ ps * feed_f, data = combined22, link = "logit", na.action = na.pass)

# Prediction grid
 ps_seq <- seq(min(combined22$ps, na.rm = TRUE),
               max(combined22$ps, na.rm = TRUE),
               length.out = 250)
 
 newdat <- expand_grid(
     ps     = ps_seq,
     feed_f = levels(combined22$feed_f)
 )
 
 # Point predictions
 newdat$pred <- predict(m, newdata = newdat, type = "response")
 
 # Bootstrap CIs
 set.seed(123)
 B <- 1000
 boot_mat <- matrix(NA_real_, nrow = B, ncol = nrow(newdat))
 
 for (b in seq_len(B)) {
   idx <- sample(seq_len(nrow(combined22)), replace = TRUE)
     dat_b <- combined22[idx, ]
     
     fit_b <- tryCatch(
         betareg(pib ~ ps * feed_f, data = dat_b, link = "logit"),
         error = function(e) NULL
     )
     
     if (!is.null(fit_b)) {
         boot_mat[b, ] <- tryCatch(
             predict(fit_b, newdata = newdat, type = "response"),
             error = function(e) rep(NA_real_, nrow(newdat))
         )
     }
 }
 
 newdat <- newdat %>%
     mutate(
         lo = apply(boot_mat, 2, quantile, probs = 0.025, na.rm = TRUE),
         hi = apply(boot_mat, 2, quantile, probs = 0.975, na.rm = TRUE)
     )
 
 # Plot
 ggplot(newdat, aes(ps, pred, color = feed_f, fill = feed_f, linetype = feed_f)) +
     geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.20, color = NA) +
     geom_line(linewidth = 1.2) +
     labs(x = "Percent shrub cover",
          y = "Predicted PIB",
          color = "Feed",
          fill  = "Feed",
          linetype = "Feed") +
     theme_classic() +
   theme(legend.position = "bottom") +
   labs(title = "2022")
 

```


Started again. Adding rainfall (cumulative).
```{r}
#First, we need to add week andn start of week to our data set to join that shit in.

s22rx_pre_uniq  <- s22rx_pre  %>% group_by(DSF) %>% slice_head(n=1) %>% ungroup() %>%
  select(pib, DSF, week, start_date_of_week, pg:hs)

s22rx_post_uniq <- s22rx_post %>% group_by(DSF) %>% slice_head(n=1) %>% ungroup() %>%
  select(pib, DSF, week, start_date_of_week, pg:hs)

combined22 <- bind_rows(
  s22rx_pre_uniq  %>% mutate(feed = 0),
  s22rx_post_uniq %>% mutate(feed = 1)
)

#Now, we'll make a lookup table:
week_lookup_22 <- combined22 %>%
  distinct(week, start_date_of_week) %>%
  arrange(start_date_of_week) %>%
  mutate(
    end_date_of_week = lead(start_date_of_week) - lubridate::days(1)
  )

# Last week end date: set to start + 6 days (or max rain date, your choice)
week_lookup_22$end_date_of_week[is.na(week_lookup_22$end_date_of_week)] <-
  week_lookup_22$start_date_of_week[is.na(week_lookup_22$end_date_of_week)] + lubridate::days(6)


rain_weekly_22 <- rain_22 %>%
  mutate(date = as.Date(date)) %>%
  select(date, rain_total_mm) %>%
  tidyr::crossing(week_lookup_22 %>%
                    mutate(
                      start_date = as.Date(start_date_of_week),
                      end_date   = as.Date(end_date_of_week)
                    )) %>%
  filter(date >= start_date, date <= end_date) %>%
  group_by(week, start_date_of_week) %>%
  summarise(
    weekly_rain_mm = sum(rain_total_mm, na.rm = TRUE),
    .groups = "drop"
  )


combined22_rain <- combined22 %>%
  left_join(rain_weekly_22, by = c("week", "start_date_of_week"))


combined22_rain %>%
  ggplot(aes(week, weekly_rain_mm)) +
  geom_col(fill = "midnight blue") +
  labs(x = "Week", 
       y = "Cumulative Rainfall",
       title = "2022") +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

#Checking for correlations:
cor_22 <- combined22_rain %>%
  select(ps, feed, weekly_rain_mm)

cor(cor_22)

# We must define new models! ps and feed strongly confounded.
## 2022 rainfall-compatible candidate models
## (No ps + feed in same model due to r > 0.7)

# 1) Shrub-only model
m22_ps <- betareg(
  pib ~ ps,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 2) Shrub + rainfall
m22_ps_rain <- betareg(
  pib ~ ps + weekly_rain_mm,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 3) Shrub * rainfall interaction
m22_ps_int <- betareg(
  pib ~ ps * weekly_rain_mm,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 4) Feed-only model
m22_feed <- betareg(
  pib ~ feed,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 5) Feed + rainfall
m22_feed_rain <- betareg(
  pib ~ feed + weekly_rain_mm,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 6) Feed * rainfall interaction
m22_feed_int <- betareg(
  pib ~ feed * weekly_rain_mm,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

# 7) Rainfall-only model
m22_rain <- betareg(
  pib ~ weekly_rain_mm,
  data = combined22_rain,
  link = "logit",
  na.action = na.pass
)

#### Plot: ps * weekly_rain_mm (10th vs 90th percentile) ####

m   <- m22_ps_int
dat <- combined22_rain

# Define dry and wet rainfall levels
rain_lo <- quantile(dat$weekly_rain_mm, 0.10, na.rm = TRUE)
rain_hi <- quantile(dat$weekly_rain_mm, 0.90, na.rm = TRUE)

# Shrub sequence
ps_seq <- seq(min(dat$ps, na.rm = TRUE),
              max(dat$ps, na.rm = TRUE),
              length.out = 250)

# Prediction grid
newdat <- bind_rows(
  tibble(ps = ps_seq,
         weekly_rain_mm = rain_lo,
         rain_level = "Dry (10th %)"),
  tibble(ps = ps_seq,
         weekly_rain_mm = rain_hi,
         rain_level = "Wet (90th %)")
)

# Model predictions
newdat$pred <- predict(m, newdata = newdat, type = "response")

# --- Bootstrap CIs ---
set.seed(123)
B <- 1000
boot_mat <- matrix(NA_real_, nrow = B, ncol = nrow(newdat))

for (b in seq_len(B)) {
  idx   <- sample(seq_len(nrow(dat)), replace = TRUE)
  dat_b <- dat[idx, ]
  
  fit_b <- tryCatch(
    betareg(pib ~ ps * weekly_rain_mm,
            data = dat_b,
            link = "logit",
            na.action = na.pass),
    error = function(e) NULL
  )
  
  if (!is.null(fit_b)) {
    boot_mat[b, ] <- tryCatch(
      predict(fit_b, newdata = newdat, type = "response"),
      error = function(e) rep(NA_real_, nrow(newdat))
    )
  }
}

newdat <- newdat %>%
  mutate(
    lo = apply(boot_mat, 2, quantile, probs = 0.025, na.rm = TRUE),
    hi = apply(boot_mat, 2, quantile, probs = 0.975, na.rm = TRUE)
  )

# Plot
ggplot(newdat,
       aes(ps, pred,
           color = rain_level,
           fill  = rain_level)) +
  geom_ribbon(aes(ymin = lo, ymax = hi),
              alpha = 0.20,
              color = NA) +
  geom_line(linewidth = 1.2) +
  labs(x = "Percent shrub cover",
       y = "Predicted PIB",
       color = "Rainfall level",
       fill  = "Rainfall level",
       linetype = "Rainfall level",
       title = "2022") +
  theme_classic() +
  theme(legend.position = "bottom")

#### 2022 Rainfall Candidate Model Ranking (with p-values) ####

extract_fit22 <- function(model, name) {
  
  sm <- summary(model)$coefficients$mean
  rn <- rownames(sm)
  
  data.frame(
    Model   = name,
    R2      = unname(performance::r2(model)$R2),
    AICc    = MuMIn::AICc(model),
    
    p_ps    = if ("ps" %in% rn) sm["ps", "Pr(>|z|)"] else NA,
    p_feed  = if ("feed" %in% rn) sm["feed", "Pr(>|z|)"] else NA,
    p_rain  = if ("weekly_rain_mm" %in% rn)
                sm["weekly_rain_mm", "Pr(>|z|)"] else NA,
    
    p_int   = if ("ps:weekly_rain_mm" %in% rn) {
                sm["ps:weekly_rain_mm", "Pr(>|z|)"]
              } else if ("feed:weekly_rain_mm" %in% rn) {
                sm["feed:weekly_rain_mm", "Pr(>|z|)"]
              } else {
                NA
              }
  )
}

summary22_rain <- bind_rows(
  extract_fit22(m22_ps_int,   "ps * weekly_rain_mm"),
  extract_fit22(m22_feed_int, "feed * weekly_rain_mm"),
  extract_fit22(m22_ps,       "ps"),
  extract_fit22(m22_ps_rain,  "ps + weekly_rain_mm"),
  extract_fit22(m22_feed,     "feed"),
  extract_fit22(m22_feed_rain,"feed + weekly_rain_mm"),
  extract_fit22(m22_rain,     "weekly_rain_mm")
) %>%
  arrange(AICc) %>%
  mutate(
    deltaAIC = AICc - min(AICc),
    weight   = MuMIn::Weights(AICc)
  )

rownames(summary22_rain) <- NULL

summary22_rain

write_xlsx(summary22_rain,
           "/Volumes/Samsung_T5/FIRE_NOBO_MANUSCRIPT/model_summary_22_rain_fixed.xlsx")

```


```